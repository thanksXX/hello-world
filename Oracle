右表匹配，左表全显示，则为“左”连接，（+）在右表，即右表匹配。


UPDATE TABLE1 SET X_ID=FC_CREATEGUID      --自动生成流水号

CREATE OR REPLACE FUNCTION FC_CREATEGUID RETURN VARCHAR2 IS
    GUID VARCHAR2(64);
  BEGIN
    GUID := SYS_GUID();
    RETURN '{' || SUBSTR(GUID, 1, 8) || '-' || SUBSTR(GUID, 9, 4) || '-' || SUBSTR(GUID,
                                                                                   13,
                                                                                   4) || '-' || SUBSTR(GUID,
                                                                                                 17,
                                                                                                 4) || '-' || SUBSTR(GUID,
                                                                                                              21,
                                                                                                              12) || '}';
 END FC_CREATEGUID;

UPDATE TABLE1 SET X_DATR=TO_DATE(SUBSTR(X_NAME,LENGTH(X_NAME)-12，8),'MM/DD/YYYY')  --截取文件名中某几位转换为时间存取
SELECT * FROM TABLE1 WHERE X_DATE=TO_DATE('11/16/2016','MM/DD/YY')   --查询2016年11月16日的所有数据
SELECT * FROM TABLE1 WHERE X_DATE BETWEEN &FROM_DATE AND &TO_DATE    --PLSQL Developer中查询数据时手动输入起始时间
SELECT * FROM TABLE1 WHERE TRUNC(X_DATE) BETWEEN ：FromDate AND :ToDate  --FContext表示法
SELECT * FROM TABLE1 WHERE TRUNC(SYSDATE)>=X_DATE AND MOD(TRUNC(SYSDATE)-X_DATE,7)=0  --查询X_DATE之后每隔7天的数据

SELECT * FROM TABLE1 GROUP BY ID HAVING COUNT(*)>1   --只显示重复数据 
SELECT * FROM TABLE1 GROUP BY ID HAVING COUNT(*)=1   --不显示重复数据 

不用主函数（max()），求薪水最高值：
select * from (select sal from emp order by sal desc)t where rownum=1;
select sal from emp where sal not in (select e2.sal from emp e1,emp e2 where e1.sal>e2.sal);

Select top 25 percent * from TABLE1；　　－－查询表中前25%的记录（sql server中有top关键字，Oracle中没有）

select * from tab1 where id in ( select id from tab1 group by id having count(id)>=3)　－－查询表中存在ID重复3次以上记录


查询A（ID，Name）中第31-40条记录，ID作为主键可能是不连续增长的列：
Sql server：
select top 10* from A where id not in (select top 30 id from A);
select top 10* from A where id>(select max(id) from (select top 30 id from A) as A);
select top 10* from (select top 40* from A order by id)t order by id desc;
select top 10* from (select top 40* from A)t order by id desc;

Oracle：
SELECT * FROM 
(SELECT A.*, ROWNUM RN FROM (SELECT * FROM A) WHERE ROWNUM <= 40）
WHERE RN >= 31 

SELECT * FROM 
(SELECT A.*, ROWNUM RN FROM (SELECT * FROM A))  
WHERE RN >= 31  and rn<=40



关于group by表内容：
2005-05-09 胜
2005-05-09 胜
2005-05-09 负
2005-05-09 负
2005-05-10 胜
2005-05-10 负
2005-05-10 负
要生成下列结果, 该如何写sql语句?
           胜 负
 2005-05-09 2 2
 2005-05-10 1 2
 
1) select rq,sum(case when shengfu=’胜’ then 1 else 0 end) as胜,
             sum(case whenshengfu=’负’ then 1 else 0 end) as负
   from tab3 group by rq
2) select N.rq,N. 胜,M. 负
   from  (select rq,count(*) 胜 from tab3 where shengfu=’胜’group by rq)N  inner join
         (select rq,count(*) 负 from tab3 where shengfu=’负’group by rq)M   on N.rq=M.rq
3) select a.rq,a. 胜 as胜,b.负 as 负
   from  (select rq,count(shengfu) 胜from tab3 where shengfu=’胜’ group by rq) a,
         (select rq,count(shengfu) 负from tab3 where shengfu=’负’ group by rq) b
   where a.rq=b.rq;



以年月日方式算出每个雇员到现在为止雇佣年限：（如Mike雇佣日期：1981-05-01，现在2016-11-18，雇佣了35年6月17天）
select empno,ename,hiredate,
       trunc(months_between(sysdate,hiredate)/12) year,
       trunc(mod(months_between(sysdate,hiredate),12)) months,
       trunc(sysdate-add_months(hiredate,months_between(sysdate,hiredate))) day
from emp;     
      --add_months(hiredate,months_between(sysdate,hiredate)) ： 年和月，不含天数

CREATE TABLE NEW_TABLE AS SELECT * FROM OLD_TABLE WHERE 1=0   --将原表中的结构复制到新表，但不复制具体数据项



SQL> DESC emp  (describe)
SQL> SET line 100
SQL> L  (list)
SQL> /  (run)
SQL> n   (设置第n行为当前行，n为自然数，0，1,2,3 ，，，）
SQL> a,job  (append,附加job行）
SQL> del n    (删除第n行，未指定则删除当前行）
SQL> del m,n   (删除第m到n行)
SQL> C/dept/emp  (change,修改或删除操作。将sql语句中的dept改为emp)
SQL> SAVE D:\SQL\SAMPLE.sql       (把SQL缓冲区的内容存入指定的文s件，这个文件叫脚本文件)
                                  (SQL*PLUS的命令不被存入SQL缓冲区)
                                  (SQL缓冲区只能存储一个SQL语句)
SQL> GET D:\SQL\SAMPLE.sql     (将脚本文件装入SQL缓冲区)
SQL> ed D:\SQL\SAMPLE      (edit)
SQL> @ D:\SQL\SAMPLE.sql     (@或START命令是把指定脚本文件的内容装入SQL缓冲区中并运行)

什么情况下创建脚本文件：
若写的SQL语句是将来反复使用的，就该把语句装入脚本文件，若写的SQL只用一次，则没必要创建脚本文件

SQL> SPOOL D:\SQL\OUTPUT    --SPOOL之后为文件名，该命令意思是在该命令之后屏幕所显示的一切都要存到D:\SQL\OUTPUT中
SQL> SPOOL OFF;              --只有输入SPOOL OFF后才能看到OUTPUT文件中内容。若输入SPOOL OUT表示其内容将送到打印机

ROW_ID                     DEPTNO    DNAMAE
-----------------------------------------------
AAAR3qAAEAAAACHAAA          10       ACCOUNTING
组成：
数据的对象编号：AAAR3q；
数据保存文件编号：AAE；
数据保存的块号：AAAACH；
数据的保存行号：AAA；



别名一经定义，在整个查询语句中就只能使用表的别名，而不能再使用表名。

ANY:  <ANY (小于最大的）；  >ANY（大于最小的）；  =ANY（等价于IN）

Oracle中rownum与order by:
SELECT * FROM (
           SELECT 列,...,ROWNUM rn
           FROM 表名称,表名称,...
           WHERE ROWNUM<=(currentPage*lineSize)
           ORDER BY 字段...)temp
WHERE temp.rn>((currentPage-1)*lineSize));  --数据分页

select * from tablename where rownum!=10;  --返回前9条记录
只能用（<,<=,!=）.   不能用:>,>=,=,Between...and.由于rownum是个总是从1开始的伪列，Oracle认为这种条件不成立。

select * from (select * from emp order by sal desc) where rownum <=5;  --先排序，再选前5
select * from emp where rownum <=5 order by sal desc;  --先选前5，再排序。先执行rownum再执行order by。
select * from (select * from table1 order by dbms_random.value()) where rownum<=5; --随机返回5条记录。

子查询中rownum必须有别名，否则不会查出记录，因为rownum不是某个表的列，不起别名无法知道rownum是子查询还是主查询的列。
查第二行后的记录可用以下子查询解决：
SQL>select * from (select rownum no,id,name from student) where no>2;
   
ORDER BY语法:
where语句中出现的子查询称为subquery（嵌套子查询）（不允许出现order by语句）：
select * from scott.emp
where ename in (select ename from scott.emp order by ename)
--ORA-00907:缺少右括号（错）

在from语句中出现的子查询称inline view（内联视图）（将上面嵌套子查询再包装一层，成为第二层查询的内联视图：）
select * from scott.emp
where ename in (select * from (select ename from scott.emp order by ename))
--(成功）

统计函数嵌套查询，select子查询字段只能使用嵌套的统计函数：
select deptno,max(avg(sal)) from emp group by deptno;  --错
select max(avg(sal)) from emp group by deptno;  --对

用存储过程写分页：
在SQL Server中用TOP分页：
select top 20,n.* from tablename n minus 
select top 10,m.* from tablename m.

在Oracle中用ROWNUM,或分析函数ROW_NUMBER:
select * from 
(select n.*,row_number() over (order by columnname) num from tablename n)
where num>=10 and num<=20
--在Oracle中，要将过程封装在包里，还要用动态游标才能实现数据集的返回

select...from...where...group by...having...order by...
执行顺序： 1、where将原记录过滤；2、group by分组；3、having过滤分组；4、select；5、order by
...where...group by...
...group by...having...
聚合函数不能在where中使用：
...where count(*)>1 --错
...having count(*)>1 --对
having中不能包含未分组列名：
select x1,count(*） from table1 group by x1 having x2 is not null; --报错：'x2'无效，因其未在聚合函数或group by字句中.
select x1,count(*） from table1 where x2 is not null group by x1;  --对
group by(所有select中非函数栏位），若只有函数栏，则group by不用写；若无group by字句，select列表中不允许字段（单行函数）与分组函数混用。
当需要使用聚合函数，又不希望由于引入聚合函数而需添加额外group by字句时，可以：支持窗口函数的dbms使用窗口函数，不支持窗口函数的dbms使用子查询。

若使用not in, 后面的子查询不能为null，否则不会返回任何结果.
IN 和NOT IN 运算符本质是OR运算
TRUE OR NULL   --TRUE
FALSE OR NULL  --NULL
NOT NULL       --NULL

IN和EXISTS:
若子查询中结果集记录较少，主查询中的表较大，且有索引时：IN
若子查询中结果集记录较大，主查询中的表较少，且有索引时:EXISTS
区分IN和EXISTS主要是造成了驱动顺序的改变（性能变化的关键）
EXISTS:以外层表为驱动表，先被访问；
IN： 先执行子查询
所以以驱动表的快速返回为目标

IN不对NULL值处理： select 1 from dual where null in (0,1,2,null)  --为空
升序排序时，null值排在最后；降序排序时，null值排在最前  （null是老大呀）
处理空值函数： select * from emp order by comm desc nulls last(first);  --null的值将排在最前（后），不管是asc还是desc
除count(*)，其他分组函数都不处理空值(NULL)；若数据库没数据，count(*)返回的不是null，而是0.
分组函数只能嵌套2层，尽管分组函数便利，但可能使系统效率明显下降，特别是大容量表格操作。因为用分组函数要扫描整个表，若用了group by字句Oracle还要排序



